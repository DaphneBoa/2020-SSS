接上周。讲到虚拟内存管理。
首先，为什么我们要了解这么底层的操作系统级别的内存管理呢？
因为在溢出型漏洞攻击中，内存地址的有效性在漏洞利用程序的编写中是首要考虑的问题。
漏洞攻击的目的，要驻留在系统内，而不是引起系统的崩溃。
如果对内存访问不对，读写到了不可用的内存地址上，
那么引起的效果是崩溃程序退出，那么攻击程序也就退出结束运行了。
所以，攻击程序必须要考虑内存地址的有效性。
-------------------------
学习了虚拟内存地址管理以后，我们就知道，内存地址的有效性和访问属性，
都是以4KB为单位的，这样是为了方便操作系统进行管理。
我们平常所用的动态地址分配，malloc和free等，在操作系统层面，
叫堆内存管理 Heap，是在虚拟内存之上的。
首先是虚拟内存分页的分配释放管理，然后在分页之上进行堆块管理。
其实堆快管理只是给应用程序提供的一个接口，不影响内存是否有效，
还是虚拟内存在管理。
堆长度可变，指定任意长度都可以，堆块是使用双链表进行管理的。
而虚拟内存分页，是使用一个定长的表就可以管理了。
上周给大家布置的作业，如果做完了，会对上面的情况有了解。
--------------------------
下面我说一下，为什么叫虚拟内存管理。
与虚拟内存对应的是物理内存。
物理内存有一个金手指，就是很多导线，插入插槽的那一段。
这些线，有的是用来传输地址的，有的是用来传输数据的。
当计算机在地址线上设置对应的地址时，内存就在数据线上用高低电平来给出数据。
这就是cpu操作数据的读，写入类似，反正都是要有地址。
大家想过这个问题没有：物理内存通常只有一个。
所以他应该只有一套地址体系，但是我们的操作系统中，同时在运行很多程序。
这些程序都需要访问地址，那如果只有一套地址体系，是不是意味着，
只要去遍历一遍这个地址体系中的所有地址，
是不是就可以把所有程序的所有的内存数据获取到了。
这个是不是很危险。
如果一个应用程序的开发人员稍有不慎，那是不是会引起整个系统的崩溃。
应用程序的开发人员，千千万万，水平参差不齐。
系统必须设计一种机制，让一个应用程序的错误，只影响这个应用程序。
也必须设计一种机制，让一个应用程序不能随意访问其他应用程序的内存。
还有另外一个更严重的问题：
大家共享一个地址空间，如何能做到你的数据不覆盖我的数据呢？
如果某个程序要用地址A，另外一个程序也非得用地址A呢？
就会引起非常麻烦的问题。
--------------------------
大家还记不记得，我们在做exe编译的时候，是不是有一个基地址的概念。
所谓基地址，就是这个exe文件在运行的时候，它的exe文件会被放到内存的那个地址上。
为什么基地址要固定，而不是动态呢？
因为只有基地址确定了以后，程序内部的很多其他的数据或者程序跳转的地址才能确定。
大家发现没有，这个地址的确定，是在程序运行之前，在编译链接的时候就确定了。
那么如何保证每个应用程序都能使用到自己想要的地址？
而且，同一个exe不是可以运行很多次吗？每个的基地址不都一样吗？
那么相互之间不会冲突吗？
大家可以做一个实验：写两个不同的exe，在vs中设置属性，让他们的基地址一样，
比如0x400000，然后同时运行这两个文件。
你还可以用调试器看，他们两个程序，确实都是占用了0x400000的地址。
这些问题的解决，就是因为虚拟地址。
也就是，我们的应用程序，我们所有编写的exe文件，所有使用的地址，
都不是物理地址，而是一套虚拟地址系统。
这个机制在Linux中同样有效。
------------------------------
那怎么虚拟呢？分页映射。
在OS的内核中，有一个非常重要的数据结构，称为分页表。
这个分页表其实就是记录了每个分页地址是否可用的。
它其实还记录了一个非常重要的内容，就是这一块分页，对应的是哪一个物理内存。
他们以4KB单位对应。
在真正的数据访问的过程中，每次访问，系统都会去查分页表，
把访问的虚拟地址，在分页表中表项的记录中找到这一块虚拟地址分页对应的物理地址分页。
分页内部的偏移不会变，而且每一个进程都有一个分页表。
所以其实可以把不同的进程的相同分页，对应到不同的物理地址上。
所以进程A在访问地址0x400000的时候和进程B在访问同样的地址0x400000的时候，
对应的是不同的物理地址。
然后，我们知道，在32位系统中，地址空间从0x0到0xFFFFFFFF，
一共4GB，也是一个进程最多可以有4GB的内存可用。
但是我们的物理内存并没有那么多，往往一个进程也使用不了4GB这么大的数据。
所以，系统是，只有进程需要使用了，才把内存分页的地址对应到物理地址上。
如果没有使用，不会白白占用物理地址。
这也解释了，为什么地址空间有了，0x0-0xFFFFFFFF,
为什么会有的地址有效，有的地址无效，
为什么有效和无效都是以4KB为单位的，要么同时有效，有么同时无效。
就是因此，有没有把这一块地址对应到一个真实存在的物理地址上的。
在编写操作系统内核的时候，有直接访问物理地址的情况，
而物理地址不存在有效和无效的问题了，一定都是有效的，它直接对应物理内存。
-------------------------------
拿出我们的编程圣经，intel程序开发手册：
https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf
在卷一的3.3，卷3的第4章，有详细的解读，但是Intel的手册太专业了，读起来很费时间。
有需要的时候查一查，但是这本书主要是给开发操作系统的人员准备的。
估计大家应该没有太多机会去参与到操作系统的开发。
我们再仔细看一下VirtualAlloc函数：https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
分配，就是以分页的大小为单位的。返回地址，是分页的基地址，是分页大小的整数倍。
分页大小呢，有两种，4KB和4MB，但是一般都是4KB，是默认设置。
---------------------------------
最后补充一点：有的时候，各个进程所使用的总内存会超过物理内存的总大小。
这种情况下，部分分页会被缓存到硬盘上。
但是缓存到硬盘上的内存分页数据在使用的时候，又需要载入到物理内存。
专业术语叫分页交换 swap。
所以有的时候，跑大型的程序，内存占用很多，超过了物理内存大小，
这时候程序仍然能运行，但是变得很慢。
就因为系统在不停的进行分页交换，而硬盘的访问比内存的速度差了1-2个数量级。
然后，进程的相同地址的分页可以映射到不同的物理地址上，
同样也能映射到相同的物理内存上。
比如动态链接库，每个进程都会调用基础的动态链接库，
但是需要在每个进程的地址空间中放置一份吗？
不用，只需要把分页表中项对应过来就好了，
让虚拟内存分页对应到已经存在的物理内存分页中。
这就是为什么有的时候启动进程比较慢，再启动就比较快了。
使用虚拟地址的这种分页的方式，虽然有地址翻译和映射的过程，但是效率更高。
就是因为对与用量很大的底层库等实际是共享的。
这也是为什么 Linux系统中动态链接库是.so后缀名。
shared object
这一部分内容，就讲完了。

【总结】
## 内存管理
* 以4KB（页）作为基本管理单元的虚拟内存管理。
* 虚拟内存管理是一套虚拟地址和物理地址对应的机制。
* 程序访问的内存都是虚拟内存地址，由CPU自动根据系统内核区中的地址对应关系表（分页表）来进行虚拟内存和物理内存地址的对应。
* 每个进程都有一个分页表。
* 每个进程都有一个完整的虚拟内存地址空间，x86情况下为4GB（0x00000000-0xffffffff）
* 但不是每个地址都可以使用（虚拟内存地址没有对应的物理内存）
* 使用VirtualAlloc API可以分配虚拟内存（以页为单位）、使用VirtualFree释放内存分页。
* 使用VirtualProtect 修改内存也保护属性（可读可写可执行）
* 数据执行保护（DEP）的基本原理
* malloc和free等C函数（也包括HeapAlloc和HeapFree等）管理的是堆内存，堆内存区只是全部内存区的一个部分。
* 堆内存管理是建立在虚拟内存管理的机制上的二次分配。
* 真正的地址有效还是无效是以分页为单位的。
* 内存分页可以直接映射到磁盘文件（FileMapping）、系统内核有内存分页是映射物理内存还是映射磁盘文件的内存交换机制。
* 完成内存分页管理的相关实验
------------------------------------------------------
如果你学通了，你就有能力去开发操作系统啦。
要想深入理解，还得动手实验。

【作业】
布置一下作业。
1、验证不同进程的相同的地址可以保存不同的数据。
（1）在VS中，设置固定基地址，编写两个不同可执行文件。
同时运行这两个文件，然后使用调试器附加到两个程序的进程，查看内存，
看两个程序是否使用了相同的内存地址；
（2）在不同的进程中，尝试使用VirtualAlloc分配一块相同地址的内存，
写入不同的数据，再读出。
2、（难度较高）配置一个Windbg双机内核调试环境，查阅Windbg的文档，了解
（1）Windbg如何在内核调试情况下看物理内存，也就是通过物理地址访问内存；
（2）如何查看进程的虚拟内存分页表，在分页表中找到物理内存和虚拟内存的对应关系。
然后通过Windbg的物理内存查看方式和虚拟内存的查看方式，
看同一块物理内存中的数据情况。
----------------------------------------------
其中第二个作业难度比较大，首先需要搭建Windbg的内核调试环境。
由于我们直接调试的操作系统内核，所以需要两台计算机安装两个Windows，
然后连个计算机使用串口进行链接，好在我们有虚拟机。
所以我们需要再虚拟机中安装一个Windows（安装镜像自己找，XP就可以），
然后通过虚拟串口和host pipe链接的方式，让被调试系统和windbg链接，windbg可以调试。
使用Windbg  内核调试 VirtualBox 关键字搜索，能找到很多教程。
如果决定Windows虚拟机太重量级了，可以用Linux虚拟机+gdb也能进行相关的实验，
以gdb 远程内核调试 为关键字搜索，也能找到很多教程。



