【mysite文件夹中的sql_injection.py】
如何运行：
这个文件是一个独立的httpserver，因此和django没有什么关系。
它的运行就是独立运行py文件。
python sql_injections.py
在vscode中调试，我们需要增加launch.json的配置。
在调试界面，点击 “增加配置”，选python 当前文件，
然后在 launch.json中，出现一个配置项，
用这种方式可以调试sql_injection。
然后点击sql_inejction文件，使其成为编辑器的当前文件，就可以调试了。
运行以后，是一个编辑框，输入学生ID，查询对应的成绩。
这里简化了很多，实际的系统不可能这么设计，肯定是需要一个用户系统的。
我们这里没有用户系统，所以示例一下。

【示例代码的漏洞】
通过直接查询数据库，我们知道当前的用户的ID是1，所以输入1，查询。
返回了用户id 1的成绩。
如果数据库中有多个用户，还可以查询Id为2和3的用户的成绩。
sql_inject漏洞就出现在这里。
大家首先看看效果，我输入1 OR 1=1 提交，查出了当前系统中所有用户的成绩。
相当于整个数据库我都获得了。
问题在代码的43行，我们直接把用户输入的数据，作为sql语句中的查询条件。
最后的 sql语句为：SELECT edu_admin_course.name, edu_admin_score.score FROM edu_admin_score INNER JOIN edu_admin_course ON edu_admin_score.course_id=edu_admin_course.id WHERE student_id = 1 OR 1=1
 查询条件变成了 student_id = 1 OR 1=1
1=1恒为真， 任何数OR真值，也是真。
所以，相当于 SELECT edu_admin_course.name, edu_admin_score.score FROM edu_admin_score INNER JOIN edu_admin_course ON edu_admin_score.course_id=edu_admin_course.id WHERE true;
或者没有WHERE，变成了无条件查询。
于是显示出了数据中的所有记录。
----------------------
还是我们之前说的，在软件安全中，有一个原则，所有用户的输入都是不可信的。
因此，我们必须对用户输入进行过滤，进行严格的限制。
那么这里提个问，如何打补丁？如何修改才能避免这个漏洞？
我提示一下：既然输入的为ID，那么ID是不是只能是整数。
我说两种方法。
一种很简单，就是对用户输入进行过滤，比如这里，
我们可以判断一下 input_data 是否数字就可以。
用python内置函数 isdigit 就可以判断，在这个具体的漏洞可以采用这种方法。
但是对于大型的系统，会有很多sql语句拼接和执行的地方。
每一个都去过滤，编程效率很低，而且不一定能保证你写的过滤就是对的。
实际系统的业务远比我们这里输入ID要复杂。
这里就在说回到Django，这就是框架ORM的意义了。
ORM完全避免了程序员直接接触sql语言，所有的sql语句都在模型管理器中有框架进行拼接。
程序员在编程时，只需要使用模型管理器提供的方法进行查询，创建等，就可以了。
比如，我们之前写的Django代码：result = Score.objects.filter(student=request.user)
底层在进行sql的拼接，就避免了这种情况。
这里我说一下，Django的模型管理器中，主要有filter get等获取数据的方法。
这些方法返回的数据类型是QuerySet数据类型。
这个数据类型是一个数据库访问的接口。
在调用filter时，实际上还未查询数据库，只是初步完成了数据库sql语句的拼接。
实际的查询是在render中进行的。
Django会根据render时需要的具体数据，来精确优化查询语句，
所以这里的result，并不是真正的查询结果，而是一个查询对象。
在模板 score.html 我们用到了 数据 {{ i.course.name }}
course是 socre表的一个外键，course.name实际是在course表中。
所以这里其实是一个跨表查询。
这种两个表的跨表查询，我们自己写的sql语言已经比较复杂了。
真实系统往往会有多个表的联合跨表查询，sql语句会非常复杂。
但是Django处理后，查询数据库的操作就变得非常简单，
把数据中的值的访问，编程了python对象的属性访问。
所以，建议大家，使用框架。
-------------------
但是，从学习的角度，我们需要知道Django内部是怎么做的，
也就是我也需要一些底层的http server的开发原理，
比如request response模式，html sql语言，数据库表结构等。
底层知识要了解，这有助于我们理解Django的工作原理，学习起来就很快。
对一些高级的操作也能比较深入理解。
但是，具体做工程的时候，就尽量不要直接使用原始的方法了。
这是从方法上给大家的建议。
就比如，学过windows GDI，都知道，所有的界面原始都是使用GDI绘制出来的，
但是如果我们写一个软件会自己去用GDI来做原始操作吗？
不会，因为有上层的软件做好了控件，我们直接调用控件，然后有了html。
我们直接编写html可以快速的构建软件界面，比自己写GDI，效率高一万倍。
别人已经做好了的事情，我要了解原理，但是没有必要自己再去做一遍。
这就是那句名言，不要重复发明轮子的意思。
------------------
好了，总结一下。
web安全介绍了xss和sql注入，我做的只是一个入门的工作。
这点知识是远远不够的，实际还需要大家花大量的时间学习更多更深入的内容。
--------------------------
补充两点 ：
student_id = 1; DROP TABLE xxx 这种注入方式，可以获得任意表的数据。
在sqlite中，大家做实验的时候，可以用PRAGMA table_info(table_name);取得表项的名字。
因为表项的名字是Django建的，我们要知道表项的名字可以用这种方法。

【二进制安全】
我们首先来复习一下之前我们学习过的缓冲区溢出漏洞。
在使用C、C++编写的原生应用程序时，CPU在执行的时候会有一个栈结构。
这个栈的结构是程序执行过程中，与程序当前运行的所处的位置密切相关的。
因此程序基本的组织单元是函数，函数的调用、返回等等是基本的操作。
一个大型的程序，会形成一个函数调用关系图。
栈，实际上是CPU用来记录当前执行到哪个函数的一个数据结构。
所以每次函数调用会入栈一些东西，函数调用返回会出栈一些东西。
由于栈和函数的这种一一对应，所以在设计的时候，
直接把与函数密切相关的局部变量和参数也顺便保存在了栈中。
如果局部变量的写入超过了预先分配的长度，就会覆盖其他数据。
栈中的数据有与执行流程相关的，例如函数执行返回地址等。
如果覆盖，就会造成执行流程的异常。
--------------------------------------
今天讲一点比缓冲区溢出更底层的，一个单独的知识点。
编写C、C++程序时，大家可能经常会遇到内存访问错误。
今天就给大家讲讲内存管理。（详见文件：【课内资源】内存管理概念）
为什么一段内存不可读了，为什么有不可访问的内存地址。
为什么有的时候会有执行异常。
等等这些问题，学了这一部分内容以后就能得到解答。
为什么要学这一部分内容呢，因为我们的漏洞的攻防是和内存密切相关的。
几乎所有的二进制安全漏洞，必然和内存有关系。
刚才那个列表，比较抽象，我们通过一些具体的实验来学习，便于理解。
--------------------------------
看这段代码：
int main() 
{
 char* a = malloc(100);
 a[101] = 'a';
}
是不是有问题？
大家可以实验一下，这段代码，在执行的时候，不会有异常情况，程序能够正常退出。
这是不是有点违反常识？好，大家可以下来实验。
-----------------------
原因在于，操作系统对内存的管理，也是有开销的。
系统本身需要在一块单独的系统内存中记录哪些内存是可用的，哪些内存是不可用的。
如果记录内存是否可用这个信息太细，那么记录所有的内存开销就很高。
比如，如果我们记录详细到每一个bit是否可用，
如果系统的内存有1GB，记录内存是否可用的内存也需要1GB。
这个开销有点太大了。所以，实际上，没有记录到这么细。
在Windows系统中，通常是以4kB为单位进行管理的。
也就是要么这4kB都可用，要么都不可用。
这样，所需要的管理数据就小得多。
和我们学校，把大家组织为班级，是一个道理。
-------------------------
所以呢，malloc还不是最底层的内存管理方式。
malloc我们称为堆内存管理。
malloc可以分配任意大小的数据，但是，malloc并不管理一块数据是否有效的问题。
而是由更底层的虚拟内存管理来进行的。
（参考：https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc）
一个4kB的内存管理单元，我们称为一个内存分页。
当malloc在内存分配时，如果已经可用的分页中，还有剩余的空间足够用，
那么malloc就在这个可用的分页中拿出需要的内存空间，返回地址。
如果已经可用的分页不够用，再去分配新的分页，然后返回可用的地址。
所以，malloc分配可以比较灵活，但是系统内部不会把内存搞得特别细碎，都是分块的。
------------------------
大家再观察另外一个现象。
在任务管理器中，大家切换到详细信息页面，看看每个进程的内存占用。
有什么规律？是不是全部都是4KB的倍数？
这两个小实验，证明了系统确实以4KB作为单元在管理内存，
要么4KB全部有效，要么全部无效。
虽然在刚才的简短程序里，我们只分配了100个字节，
但是这100个字节所在的整个4KB的内存全部是可用的。
然后，我们每个4KB的内存分页，其实有三个属性——可读可写可执行。
（参考资料：https://docs.microsoft.com/zh-cn/windows/win32/memory/memory-protection-constants）
所以，我们甚至可以分配一块read-only的内存。
------------------------
那么如何改变一块内存的访问属性呢？用VirtualProtect 函数。
虚拟内管管理，系统也提供了一些的函数来让应用程序可以自己管理。
分配内存是用 VirtualAlloc，释放使用VirtualFree，
修改属性使用 VirtualProtec，大家记住这三个函数。
只要是VirtualAlloc分配的内存，就可以使用。
VirtualAlloc甚至可以指定希望将内存分配在哪个地址上。
---------------------
malloc函数底层也会调用VirtualAlloc函数，
当没有足够的整页的内存可用时，malloc会调用VirtualAlloc。
所以，实际的内存分配，没有那么频繁。
好，搞清楚了这个，以后才能正确处理内存相关的错误。
今天先做一点，比较基础的作业。

【作业】
作业：
1、阅读VirtualAlloc、VirtualFree、VirtualProtect等函数的官方文档。
2、编程使用malloc分配一段内存，测试是否这段内存所在的整个4KB都可以写入读取。
3、使用VirtualAlloc分配一段，可读可写的内存，写入内存，然后将这段内存改为只读，
再读数据和写数据，看是否会有异常情况。
然后VirtualFree这段内存，再测试对这段内存的读写释放正常。
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree

【学生提问环节】





